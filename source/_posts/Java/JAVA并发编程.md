---
title: JAVA并发编程
date: 2021-02-17
categories: Java
tags:
	- Java	
	- 并发
---

# JAVA并发编程

## 并发编程Bug的源头

合理的并发程序能够极大的提升程序的性能， 但并发编程也是程序诸多Bug中最臭名昭著的一个。 因为他不以发现不易解决。 

所以，为了根治这些Bug，我们要去发掘并发编程各种Bug产生的源头： 原子性，可见性和有序性问题。 

并发编程的三大问题：安全性问题；活跃性问题；性能问题

安全性问题的源头：原子性；可见性；有序性

安全性问题出现的根本原因：数据竞争（多个线程读写共享数据）；竞态条件（程序的执行结果依赖线程执行的顺序）

活跃性问题的三种情况：死锁；活锁；饥饿

性能问题的衡量：阿姆达尔定律

性能问题的几种思路：无锁方案（TLS、COW、乐观锁）；减少锁粒度

Await()阻塞被唤醒之后，是从await()下面的方法开始执行的，这里很容易想象成从头执行，其实从头执行好好想想就不对劲。 

> 线程让出CPU是需要保存线程执行的上下文的， 会把相关寄存器--包括PC寄存器（保存的是下一次要执行的指令地址）保存在TCB（线程控制块），因为当该线程被唤醒后，重新获取锁后，开始执行时，从TCB中重新加载PC寄存器的值，这里就会从await之后开始运行的，所以需要while交验的（因为从唤醒到正式只执行是有一段时间的，此时状态可能已经发生变化）





### 读写锁

获取写锁的前提是读锁和写锁均未被占用
获取读锁的前提是没有其他线程占用写锁
申请写锁时不中断其他线程申请读锁
公平锁如果过有写申请，能禁止读锁

### StampedLock

[Java多线程进阶（十一）—— J.U.C之locks框架：StampedLock](https://segmentfault.com/a/1190000015808032)

支持乐观读， 此时无需加锁，提高性能。 

StampedLock在获取写锁之后，会返回不同stamp。因为如果stamp不同， 则表示有线程持有写锁。

一般stamp为0代表获取锁失败。 

#### 最佳实践

乐观锁读模版

```

final StampedLock sl = 
  new StampedLock();

// 乐观读
long stamp = 
  sl.tryOptimisticRead();
// 读入方法局部变量
......
// 校验stamp
if (!sl.validate(stamp)){
  // 升级为悲观读锁
  stamp = sl.readLock();
  try {
    // 读入方法局部变量
    .....
  } finally {
    //释放悲观读锁
    sl.unlockRead(stamp);
  }
}
//使用方法局部变量执行业务操作
......
```

乐观锁写模版

```

long stamp = sl.writeLock();
try {
  // 写共享变量
  ......
} finally {
  sl.unlockWrite(stamp);
}
```



### CAS CPU原子指令级操作

## 问题

使用乐观锁的本质是为了提高读和写的那一瞬间的性能？

为什么最好不要Executors提供的线程池

HashMap为什么是线程不安全的？

> 参考：[面试官：你说 HashMap 线程不安全，它为啥不安全呢？](https://mp.weixin.qq.com/s/yxn47A4UcsrORoDJyREEuQ)

另外，使用实现原子性操作时，需要避免共享变量使用volatile， 此变量会始终让线程读取到最新值， 另外这里如果对象是引用类型，则更加的需要注意。



### 模式

#### 不可变模式

不可变对象原子性通过原子类来保证。  

1. 不可变类的特点：类、属性都是final的，方法是只读的
2. 为了解决有些不可变类每次创建一个新对象导致内存浪费的问题：享元模式/对象池
3. 注意事项：区别引用不可变和实际内容不可变
4. 更简单的不可变对象：无状态对象