---
title: Java虚拟机
categories: Java
tags:
  - Java
abbrlink: 515d78b5
date: 2021-10-01 20:02:03
---
#的基础类型

### 虚拟机所看到的Boolean类型

在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。

Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于 boolean 类型的条件跳转。这样一来，在编译而成的 class 文件中，除了字段和传入参数外，基本看不出 boolean 类型的痕迹了

### Java基本类型的大小。

在C++，乃至常规的Java课本上，我们都有听过下面的理论，即boolean类型占一个字节，short占两个字节，int占四个字节，long占8个字节，这种说法是不对的，或者说不是全对，他们在栈中和堆中所占用的大小略有不同。

Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便理解，这里我只讨论供解释器使用的解释栈帧（interpreted frame）。

这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数

实际上，在Jav虚拟机规范中，局部变量等价于一个数组， 并且可以用正整数来进行索引， 除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。（这里的一个数组单元，你可以理解为操作系统的位数，其实跟内存的排线有关。）

也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

当然，这种情况仅存在于局部变量，这也就是我刚才所说的“不是全对”，在堆中，上面讲的理论又是生效的。 

在存储于堆中和数组元素中的元素，对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。 

因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。

boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。

## Java 虚拟机的类加载机制

说到类加载机制，不得不说一下Java的数据结构。 

Java有8大数据类型，我们可以理解为8种最基本的数据结构。  分别为： boolean、byte、char、short、int、long、double、float。  那这个类型都是虚拟机预先就定义好的，我们不做拓展。 

8个基本数据类型存储的都是单一的元素，每个结构都只能存储一个值，这怎么能行，大中国都14多亿人。 所以，除了单一数据结构，我们还需要一个能存多个元素的数据结构，其实不能算结构，它只是能一串连续存储数据的地址而已。 

说完基本类型和数组之后，我们来说说引用类型，引用类型只有一种，那就是类（在我的理解里数组可能不算类型，个人观点，不喜勿喷）。 那这里就需要知道虚拟机是怎么使用类这种特殊结构的，毕竟类这个东西，谁都能定义，定义的五花八样，每个人定义成啥样，虚拟机事先肯定不知道。 

Java虚拟机将一个类从一个class磁盘文件加载到内存变成一种数据结构，需经过加载、链接、初始化三个过程。 

Java在编译时会将我们的代码写的类编译成class文件，这也是我们常说的字节流（字节码），怎么叫都行，除了.class文件，我们也可以在内部程序直接生成，或者从网络中读取（例如网页内嵌的小程序Java applet）。 这些不同形式的字节流，最后都被加载到虚拟机中，然后让虚拟机来调用。 

那我们就搞清楚类从字节流变成虚拟机可以使用的数据结构，中间都经历过什么，这里为了方便，我们还是叫类。 

### 加载

加载，是指查找到对应的字节流，并并根据字节流的内容来创建类的一个过程。 通常，Java虚拟机加载一个类需要借助一个工具来完成，那就是**类加载器**

虚拟机有各种各样的类加载器，当然，类加载器也是有家族关系的，不是从石头里蹦出来的。  也就是类加载器也有父加载器和加载器。 那各种各样的加载器，一个类到底会被那个加载器来加载呢。 

那这里又多了一个名词，那就是听起来十分牛逼的“双亲委派模型”， 这个名词咋一听，感觉根本听不懂，其实很简单。 简单来说，双亲委派模型的定义时，任何一个类加载器在加载一个类时，会先尝试让它的爸爸来加载这里类，如果他爸不想加载这个类，他自己才会来加载这个类。 这就是双亲委派模型。 

在这么多加载器，谁是这些加载类的祖师爷呢，叫启动类加载器（bootstrap class loader）， 是由C++实现的，谁也看不到它，只有真正核心的类，才会值得它出马，换句话说，他只会加载存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。 另外两个重要的类加载器，分别是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。

扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。 Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载

应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

### 链接

当虚拟机创建完类之后，将其合并到虚拟机中，使其能够执行的过程，我们称为类的链接。 它可以分为验证、准备、解析三个阶段。 

“验证”阶段的目的，在于确保被加载的类能够满足虚拟机的约束条件。 具体条件我也不清楚，自己去百度。 一般来说，通过java正常编译的类，都能够满足这个条件。 怕就怕一些邪魔外道，比如字节码注入。 

“准备”阶段的目的，则是为加载类的静态字段分配内存，Java代码中对静态字段的初始化，会在初始化阶段中进行，这里并没有真正的做初始化，只是分配一段内存。 

除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

“解析”阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

### 初始化

在Java代码中，我们要给一个静态字段复制，我们可以在声明一个静态字段的同时给字段复制，也可以在静态代码块中对其赋值。 

如果直接赋值的静态字段同时被final修饰，并且他的类型是基本类型或者字符串时，那么该字段会被Java编译器标记为常量值， 在初始化的时候由虚拟机直接完成。 除此之外的赋值操作，则会被Java编译器置于同一个方法中，并把这个方法命名为<clinit>。 

在真正初始化的阶段，虚拟机先是直接为常量值赋值，随后调用<clinit>方法，调用过程，虚拟机会通过加锁来确保这个方法只被执行一次。 

只有当初始化完成之后，类才正式的成为可以执行的状态。 

那么类什么时候初始化才会被出发呢？这个问题提出来，除了问题本身，其实说明了类并不是一开始加载、链接后就被初始化。 而是在某些情况下才会出发类的初始化操作。 

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

简而言之，就是只有这个类被真正调用的时候，这个类才会被初始化。 

延迟初始化的这个特性，可以应用到很多场景，最常用的便是单例模式。 

```java

public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
}
```

在上面代码。 只有真正的执行`Singleton.getInstance` 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例

由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。

#### 问题

### **新建数组会导致 LazyHolder 的加载吗？如果加载，会导致它的链接，会导致它的初始化吗？**

**在链接过程的“准备阶段”是给静态变量分配内存，静态字段并没有初始化，分配的内存到底有什么作用？**

**验证类所需要满足的约束条件到底是哪些？**

## Java的方法调用过程



方法的符号引用存储在文件的常量池中。 根据目标方法是否为接



### 问题

**内联缓存存在那个级别，方法？类？ 一个方法一个缓存，还是一个类一个缓存？内联存储的结构是怎么样的？**

> 个人倾向于在类级别， 结构为。Class.method: 1 这个结构。 并且这样的结构代表了单态内联缓存缓存一个方法。 如果同一个类型的另一个方法被调用，也会替换这个值。  





## Java的反射实现过程

### 问题

什么是Java的inline

每一个动态实现都会生成一个崭新的GeneratedMethodAccessor？ 即GeneratedMethodAccessor1， GeneratedMethodAccessor2 ？ 

## Java的对象的内存布局。 

在Java虚拟机中，每个Java对象都有一个对象头（Obj ect header)

在64位的Java虚拟机中，对象头的标记字段占64位。 

