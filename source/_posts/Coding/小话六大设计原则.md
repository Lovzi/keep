---
title: 六大设计原则
categories: Coding
tags:
  - Coding
abbrlink: 1a8d071a
date: 2021-08-26 10:55:17
---



思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。

**先补充一下设计模式、设计原则等思想提供的特性。**

灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）

### **高质量代码考量维度**

可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性

## **设计模式的利器---面向对象**

什么是面向过程编程与面向过程编程语言？

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石

### **抽象**

抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一

### **继承**

继承的特性



继承的副作用

1. 代码的可读性变差

### **组合**

### **组合VS继承**

### **面向对象分析**

### **面向对象设计**

大多数讲面向对象的书籍中，还会讲到另外一种识别类的方法，那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。

面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。

**1. 划分职责进而识别出有哪些类**

根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

**2. 定义类及其属性和方法**

我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

**3. 定义类与类之间的交互关系UML**

统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

**4. 将类组装起来并提供执行入口**

我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来

### **面向对象编程**

## **设计原则**

### **1 开放封闭原则**

对拓展开放、对修改封闭

**怎样去理解？**

> 添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”
>
> 换句话说， 开放拓展是为了适应变化， 关闭修改时为了代码的稳定（不改变原有功能，不用新做单元测试）

为什么需要遵循开放封闭原则？

> 修改某段代码（比如某个函数）可能会导致引用此段代码（函数）的功能受到影响，需要重新对代码进行全面的测试,有些改动需要对原来的代码做大规模的改动甚至重新构造系统.
>
> 而对拓展新的功能应该开放,是系统具备良好的拓展性，以适应未来可能出现的变化

**修改代码就意味着违背开闭原则吗?**

> 只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，就是一个合格的代码改动

如何遵循开放封闭原则：

1. 提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等
2. 编写代码时思考这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
3. 在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

#### 经验之谈

1. 当某个功能市场上已有多种技术可以实现，则要通过接口或者抽象类作为参数，基于抽象编程，这样在切换一个新技术的时候，上游系统可以不用改动。
2. 同样，当某个上游系统，通用框架，由多个下游业务调用。则一定要开放出接口供他人调用。
3. 对一些短期内就能看发现有多个业务需要拓展的，大可放心使用开闭。 如果某些业务很长一段时间不会去改，则不要过度设计。
4. 代码可读性和可拓展性两者总是需要取舍，合理设计平衡，切莫过度设计。

#### 总结

开闭原则旨在提高代码以下特性：

- 可维护性
- 可拓展性
- 可测试性。

### **2 里氏替换原则**

含义： 基类可以直接被替换成子类，换句话说。基类可以出现的地方、子类一定能出现

为什么需要遵循里氏替换原则？

> 一个子类一定数据对应的基类，就好比男人一定属于人。因此人可以出现的地方，
>
> 男人一定可以出现，因为男人具有人的所有属性和行为。所以，子类应该能替换基类所处的位置。
>
> 并在此基础上，能够为基类增加新的功能。
>
> 如果修改了基类的某个方法实现，则会导致其他继承基类的子类的该方法被改变。

解决办法：使用抽象类继承，而不是用具体类继承。若是继承具体类，也不应该重写某具体方法，只能增加新的方法。

注意： 对Python来说同样适用

### **3 依赖倒转原则**

定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；

抽象不应该依赖细节；细节应该依赖抽象。

为什么需要遵循依赖倒转原则？

> 高层模块Person直接依赖底层模块Book会限制高层模块Person的拓展性，假设某天高层模块需要依赖其他底层模块时(想读报纸)，
>
> 则需要修改对应的高层模块（修改阅读方法，去加一个读报纸）。这样显然不合理。

解决办法：

> 报纸和书籍统一继承抽象类（读物）或者直接继承接口IReader，实现对应的获取内容方法
>
> 在Person中形参设为抽象类（读物）或者IReader。通过Java多态获取对应的底层模块或类的方法。

注意：Python由于不限定某个参数的类型，这样虽可以避免直接依赖某个底层模块。

但太过灵活性可能导致错误传参造成错误。因此，在Python编程中应同样继承抽象类读物。

栗子：

```python
from abc import abstractmethod, ABCMeta

class Reader(metaclass=ABCMeta):
  @abstractmethod
  def get_content(self):
    pass
  class Newspaper(Reader):
    def get_content(self):
      return'报纸内容.....'
    
 class Book(Reader):
  def get_content(self):
    return'书的内容'
  
 class Person:
  def read(self, reader):
    if isinstance(reader, Reader):
			print(reader.get_content())
    else:
      print('未知读物')

Person().read(Book())

Person().read('sdfsdf')
```

### **4 单一职责原则**

定义： 同一个类或者方法应该只有一项职责

为什么要遵守单一职责原则？

1. 同一个方法实现了两个功能，将无法对某一个功能进行重用。使代码过于冗余

2. 若一个类或者方法同时拥有职责A或者职责B,在某个功能被改变之后，可能对另一个功能造成影响

   使另一个功能无法正常执行。

解决方案：对方法和类进行拆分，拆成更细粒度的功能，在实现时请确认是否是一个功能。

有些时候写着写着，单一职责原则就变的不单一了。是因为最开始的时候，

你认为的单一职责可能会有很多种情况，可以被拆成更细粒度的。

#### 总结

单一职责原则的作用

1. 可复用性
2. 可维护性

### **5 迪米特原则（待深入理解）**

定义： 一个对象应该对其他对象保持最少的了解，一个类应该对自己需要耦合或调用的类知道得最少，

迪米特原则也叫最少知道原则，且一个对象只和自己的朋友通信。

这样做的原因是为了让代码更加“高内聚”，“低耦合”

“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。

换句话是这样讲的。不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）

迪米特法则还有一个更简单的定义：只与直接的朋友通信。

首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，

我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，

我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。

也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。

为什么要遵守迪米特原则？

> 一般在使用框架的时候，框架的开发者会抽出一个类供外部调用，
>
> 而这个主要的类像是一个中介一样去调用框架里面的其他类，
>
> 恰恰框架里面其他类一般都是不可访问（调用）的，这个框架就遵守了迪米特原则，
>
> 其他开发人员只关心调用的方法，并不需要关心功能具体如何实现

解决方案：降低类与类之间的耦合。

### **6 接口隔离原则**

定义: 在定义接口方法时应该合理化，尽量追求简单最小，避免接口臃肿

换句话说,客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者

实际上，“接口”这个词，既可以狭义表示Java的接口， 也可以表示一种约定的抽象。比如

1. 一组REST API接口
2. 某个库的API接口
3. Jaba中的interface

为什么要遵守接口隔离原则？

> 在实际开发中，往往为了节省时间，可能会将多个功能的方法抽成一个接口，其实这设计理念不正确的，
>
> 这样会使接口处于臃肿的状态，这时就需要合理的拆分接口中的方法，另外抽取成一个独立的接口，
>
> 避免原有的接口臃肿导致代码理解困难

### **7 DRY原则**

DRY 原则是一条原则：不要写重复的代码

首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。

其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。

#### 怎么提高代码复用性？

- 减少代码耦合

> 对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。

- 满足单一职责原则

> 我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用

- 模块化

> 这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统

- 业务与非业务逻辑分离

> 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。

- 通用代码下沉

> 从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。

- 继承、多态、抽象、封装

> 在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。

- 应用模板等设计模式

> 一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。

除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性。

#### 总结

- 代码越通用，就越可能被复用。
- 即使代码不重复，也可能不符合DRY.

### **六大原则小结**

- 代码应该对修改关闭，但对拓展开放（开闭原则）
- 子类不该修改父类已经实现的功能（里氏替换原则）
- 高级类不该依赖某个具体的实现，而应该依赖于抽象类（某一类事物），从而适应变化。（依赖倒转原则）
- 每个类和方法只要实现同一个任务，若这个任务具有变化性，则应该进行拆分。（单一职责原则）
- 不要实现无用的方法（接口隔离）
- 不要依赖陌生人。（迪米特原则）

### **个人思考**

1.不要对在现实生活中抽象事物的某些属性和行为进行实现，

除非你确定这个抽象在被继承后，子类所拥有的行为是所有的功能都一样。----关于单一职责引发的思考

> 举个栗子，人都是呼吸空气，那么人这个抽象事物可以实现呼吸方法。
>
> 但是动物不全是呼吸空气，比如鱼和牛。那么动物就不该去实现具体的呼吸方法，
>
> 而是使用抽象方法，让子类去实现对应的具体细节。

网上反面教材：动物类的呼吸方法不该直接实现，同样动物也不该被实例，他是一个抽象概念。

```java

class Animal{

    public void breathe(String animal){
        System.out.println(animal+"呼吸空气");
    }

}

public class Client{
    public static void main(String[] args){

        Animal animal = new Animal();

        animal.breathe("牛");

        animal.breathe("羊");

        animal.breathe("猪");

    }
}
```



在设计中，多去思考这个类是否是抽象事物，他的行为属性是否会在子类的过程中被改变。

1. 降低耦合，一个方法尽量不要引用外部的变量，除非是常量。

> 一个方法，若引用过多的外部变量，若外部变量被改变，则函数的返回结果很有可能被改变。
>
> 一个函数应该在同样的参数下返回同样的值。
